# Postman Anonymous Cart Testing

## Purpose of This Document

This document describes how **Anonymous Cart behavior** is tested using **Postman**, both locally and in **CI (Postman CLI)**.

The goal is not only to validate API correctness, but to:

- verify **realistic guest → authenticated user flows**,
- assert **business rules** defined in ADR-018,
- provide **deterministic, maintainable E2E-style API tests**,
- and serve as **living test documentation**.

Anonymous Cart is a stateful feature. Postman is intentionally used here to validate **state transitions across multiple requests**, something unit tests alone cannot fully cover.

---

## Scope

Covered scenarios:

- Guest cart creation and persistence
- Token-based cart identification (cookie + header)
- Guest → Register → Login → Cart adoption
- Guest → Login → Cart merge into existing user cart
- Merge conflict handling (stock overflow)
- Token invalidation and idempotency

Not covered here:

- Pricing rules (covered in Sprint 7 tests)
- Checkout → Order → Payment flow
- Frontend/browser-level behavior (covered later by Playwright)

---

## Anonymous Cart Identification Strategy

### Token-based Identification

Anonymous carts are identified by an **opaque cart token** generated by the backend.

Transport mechanisms:

1. **Primary**: HTTP-only cookie (`cart_token`)
2. **Secondary (testing/debug)**: request header `X-Cart-Token`

Server-side behavior:

- Token value is **never stored in plaintext**.
- Only a **SHA-256 hash** of the token is persisted in the database.
- Token uniquely identifies one active anonymous cart.

### Why Cookie + Header?

| Mechanism               | Purpose                                       |
| ----------------------- | --------------------------------------------- |
| HTTP-only cookie        | Realistic browser behavior, secure by default |
| Header (`X-Cart-Token`) | Deterministic testing, Postman/CI friendly    |

Header takes precedence over cookie when both are present.

---

## Postman Testing Architecture

### Design Principles

- ❌ No hardcoded IDs
- ❌ No manual copying of values
- ✅ Deterministic, repeatable tests
- ✅ Same collection works locally and in CI
- ✅ Business logic lives in helpers, not in requests

### Variable Strategy

| Variable        | Scope       | Description                              |
| --------------- | ----------- | ---------------------------------------- |
| `cart_token`    | Collection  | Guest cart token                         |
| `access_token`  | Environment | JWT access token                         |
| `refresh_token` | Environment | JWT refresh token                        |
| `seed_products` | Collection  | Seeded product lookup (from CI fixtures) |

---

## Collection-Level Helpers

### Cart Token Helpers

#### Capture cart token from response

```javascript
function setCartTokenFromResponse() {
  const cookies = pm.cookies.toObject();

  if (cookies.cart_token) {
    pm.variables.set("cart_token", cookies.cart_token);
    return;
  }

  const json = pm.response.json();
  if (json.cart_token) {
    pm.variables.set("cart_token", json.cart_token);
  }
}
```

Used in:

- POST /cart/items
- GET /cart (if cart is created lazily)

#### Attach cart token to request

```javascript
function attachCartToken() {
  const token = pm.variables.get("cart_token");
  if (!token) return;

  pm.request.headers.upsert({
    key: "X-Cart-Token",
    value: token,
  });
}
```

Used in Pre-request Script of all cart-related requests.

### Authentication Helpers

#### Store JWT tokens

```javascript
function setAuthTokens() {
  const json = pm.response.json();
  pm.environment.set("access_token", json.access);
  pm.environment.set("refresh_token", json.refresh);
}
```

#### Attach access token

```javascript
function attachAccessToken() {
  const token = pm.environment.get("access_token");
  if (!token) return;

  pm.request.headers.upsert({
    key: "Authorization",
    value: `Bearer ${token}`,
  });
}
```

## Folder Structure & Scenarios

### Folder: Guest Cart

**Scenario**

Guest user creates and accesses a cart without authentication.

**Assertions**

- Cart is created implicitly
- Cart status is `ACTIVE`
- Items persist across requests
- Token is set via cookie

### Folder: Guest → Register → Login (Adoption)

**Scenario**

1. Guest adds items to cart
2. User registers (still guest)
3. User logs in with guest token
4. Guest cart is adopted as user cart

**Expected Behavior**

- Guest cart becomes the user’s active cart
- Items are preserved
- Guest token is invalidated

**Assertions**

- GET /cart as user returns previous guest items
- Old guest token no longer accesses the adopted cart

### Folder: Guest → Login (Merge)

**Scenario**

- User already has an active cart
- Guest has a cart with overlapping products
- User logs in using guest token

**Expected Behavior**

- Items are merged per product
- Quantities are summed
- Merge happens exactly once (idempotent)

### Folder: Merge Conflict (Stock Overflow)

**Scenario**

- User cart quantity + guest cart quantity exceeds available stock

**Expected Behavior**

- Login fails with HTTP 409
- Error response follows unified shape

```json
{
  "code": "CART_MERGE_STOCK_CONFLICT",
  "message": "..."
}
```

This validates a business rule, not just a technical constraint.

## Idempotency & Safety Guarantees

Postman tests explicitly validate that:

- Reusing the same guest token after login does not re-merge carts
- Token invalidation is enforced
- Login with an invalid token is a safe no-op or rejected (never duplicates data)

These scenarios are especially important for MySQL and concurrent environments.

## CI Compatibility

The collection is fully compatible with:

- Postman CLI
- Base64-injected fixtures
- Headless execution

No Postman GUI-specific features are used.

This ensures:

- identical behavior locally and in CI
- reproducible failures
- audit-friendly test runs

## Why This Matters (Testing Perspective)

Anonymous Cart is a **high-risk, stateful feature**:

- touches pricing, stock, orders, and authentication
- spans multiple requests and user states
- prone to race conditions and duplication bugs

By testing it via Postman:

- we validate real user journeys
- we test cross-request invariants
- we document business rules through executable tests

This approach aligns with:

- TDD / Documentation-Driven Development
- QA ownership of critical business flows
- Production-like confidence without frontend dependency
